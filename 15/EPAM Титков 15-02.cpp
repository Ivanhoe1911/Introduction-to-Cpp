/**
*
* Титков Иван
* 2. Определить класс для работы с односвязным списком. Элементы списка - целые числа.
* Создать список. Найти в списке максимальный элемент и удалить его.
*
*/

#include <iostream>
#include <ctime>
#include <iomanip>

using namespace std;

class SList					// Класс "Односвязный список".
{
public:
	SList();				// Конструктор по умолчанию.
	SList(int data);		// Конструктор с параметром.
	~SList();				// Деструктор.
	void addNode(int);		// Функция добавления элемента в список.
	void showNodes();		// Функция вывода элементов списка на экран.
	int findMax();			// Функция поиска максимального элемента в списке.
	void delNode(int);		// Функция удаления элемента списка по значению.

	int createCount;		// Счетчик элементов в списке, для отладки.
private:
	struct Node				// Элемент списка: структура с даннымы.
	{
		int data;			// Данные элемента: целое число.
		Node *nextNode;		// Указатель на следующий элемент с данными.
	} *firstNode, *lastNode;// Указатели на первый и последний элементы списка.	
};

SList::SList()				// Конструктор по умолчанию.
{
	firstNode = NULL;		// Начальные значения списка не задаются, т.к.
	lastNode = NULL;		// это будет сделано через функцию добавления элемента.

	createCount = 0;		// Инициализация счетчика элементов в списке.
}

SList::SList(int data)			// Конструктор с параметром.
{
	firstNode = new Node;		// Создание первой записи в списке.

	firstNode->data = data;		// Заполнение первого элемента данными.
	firstNode->nextNode = NULL; // Первая запись является вначале
	lastNode = firstNode;		// также и последней.

	createCount = 1;			// Инициализация счетчика элементов в списке.
}

SList::~SList()					// Деструктор.
{
	int delCount = 0;			// Счетчик количества удаленных элементов списка, для отладки.
	Node *temp = firstNode;		// Удалются элементы под временным указателем, начиная с первого.

	// Указатель на первый элемент сдвигается к следующему, а его предыдущая запись,
	// хранящаяся во временном указателе удаляется. И так по циклу.
	while (firstNode != NULL)		// Цикл повторяется пока не дойдет до последнего элемента списка.
	{
		firstNode = temp->nextNode;	// Указатель на первый элемент переходит к следующему,
		delete temp;				// а предыдущий первый элемент очищается.
		temp = firstNode;			// Перевод удаляющего указателя к следующему элементу.
		++delCount;					// Счетчик удалений - отладочная информация.
	}
	lastNode = NULL;				// Обнуление указателя на последнюю запись, необязательно.
	// Вывод на экран количества очищенных участков памяти, выделенных под элементы списка.
	cout << "Сработал деструктор, удалено " << delCount
		<< " элемента(ов) из " << createCount << '.' << endl;
}

void SList::addNode(int data)	// Функция добавления элемента в список.
{
	++createCount;				// Увеличение счетчика записей в списке, для отладки.

	// Если сработал конструктор по умолчанию, то элементов еще нет и надо создать первый.
	if (firstNode == NULL)
	{
		firstNode = new Node;		// Выделение памяти для первого элемента в списке.

		firstNode->data = data;		// Заполнение первого элемента данными.
		firstNode->nextNode = NULL; // Первая запись является вначале
		lastNode = firstNode;		// также и последней.

		return;				// Выход из функции, т.к. внесение первого элемента на этом окончено.
	}

	// Если в списке уже есть элементы.
	Node *newNode = new Node;		// Формирование нового элемента.

	newNode->data = data;			// Заполнение его данными.
	newNode->nextNode = NULL;		// Теперь он будет являтся последним.

	lastNode->nextNode = newNode;	// Последний элемент теперь ссылается на новый как на следующий.
	lastNode = newNode;				// Новый элемент объявляется последним.
}

void SList::showNodes()				// Функция вывода записей в консоль.
{
	Node *temp = firstNode;			// Временная переменная будет перебирать список с первого элемента.
	while (temp != NULL)			// Цикл повторяется, пока не дойдет до последней записи,
	{								// и не начнется если записей еще нет.
		cout << temp->data << ' ';	// Вывод на экран текущего содержимого записи.
		temp = temp->nextNode;		// Временнаяя переменная переходит на следующую запись.
	}
}

int SList::findMax()			// Функция поиска максимального элемента в списке.
{
	int max = firstNode->data;	// Использование первого элемента в списке в качестве базы для сравнения.

	Node *temp = firstNode->nextNode;	// Временный указатель идет по списку,
	while (temp != NULL)				// пока в нем есть элементы.
	{
		if (temp->data > max)	// Если текущий элемент списка больше максимального,
		{						// то он новый максимальный
			max = temp->data;
		}
		temp = temp->nextNode;	// Переход к следующему элементу в списке.
	}
	return max;					// Возврат найденного максимального значения элемента.
}

void SList::delNode(int del)		// Функция удаления элемента списка по значению.
{
	Node *temp = firstNode;			// Временный указатель, будет перемещаться по элементам, начиная с первого.

	// Цикл для случая, когда удаляемый элемент является первым, т.е. надо менять указатель на первую запись.
	while (firstNode != NULL && firstNode->data == del)	// Цикл продолжается пока есть что проверять,
	{													// также проверяя соответсвие записи условию удаления.
		firstNode = firstNode->nextNode;	// Указатель первого элемента переводится на следующий.
		delete temp;						// Очистка памяти от первого элемента.
		--createCount;						// Уменьшение счетчика элементов списка.
		if (firstNode == NULL)				// Если удаленный элемент являлся последним,
		{									// то обнуляется указатель и на последний элемент
			lastNode = NULL;				// и выход из функции т.к. нечего больше проверять.
			return;
		}
		temp = firstNode;					// Временный указатель переводится на новый первый элемент,
	}										// если еще есть что проверять.

	// Цикл для всех остальных случаев. Используется временный указатель и указатель на последнюю запись,
	// т.к. для удаления записей нужен еще один указатель, хранящий адрес следующей записи.
	lastNode = firstNode;					// Возврат указателя последней записи в начало списка.
	temp = lastNode->nextNode;				// Временный указатель проверяет следующее за ним значение.
	while (temp != NULL)
	{
		if (temp->data == del)				// Если запись подлежит удалению,
		{
			lastNode->nextNode = temp->nextNode;	// то предыдущая запись ссылается на запись после удаляемой,
			delete temp;							// а текущая запись удаляется из памяти.
			temp = lastNode->nextNode;
			--createCount;					// Уменьшение счетчика элементов в списке.
		}
		else								// Если запись не подлежит удалению, то переход к следующей.
		{
			lastNode = temp;
			temp = lastNode->nextNode;
		}
	}
}

void pushMain(SList*, int);	// Функция заполнения односвязного основная, ее будут вызывать другие.
void pushRand(SList*);		// Функция заполнения односвязного списка случайными значениями.
void pushManual(SList*);	// Функция заполнения односвязного списка вручную.

int main()
{
	setlocale(LC_ALL, "ru");

	int choice;			// Переменная для главного меню.
	SList myList;		// Создание экземпляра списка.

	// Главное меню.
	while (true)
	{
		cout << "Односвязный список." << endl
			<< "1) Заполнить список случайными значениями." << endl
			<< "2) Заполнить список вручную." << endl
			<< "3) Удалить максимальные элементы из списка." << endl
			<< "4) Вывести содержимое списка на экран." << endl
			<< "5) Выход." << endl
			<< "Выберите вариант: ";
		cin >> choice;

		switch (choice)
		{
		case 1:	system("cls");
			pushRand(&myList);								// Добавление случайных значений в список.
			cout << "Значения добавлены." << endl << endl;
			break;
		case 2:	system("cls");
			pushManual(&myList);							// Добавление в список значений в ручную.
			cout << "Значения добавлены." << endl << endl;
			break;
		case 3:	system("cls");
			if (myList.createCount == 0)					// Если список пустой, то выводится предупреждение.
			{
				cout << "Сначала добавьте значения!"
					<< endl << endl;
				break;
			}
			cout << "Элементы списка до удаления:" << endl;	// Вывод элементов списка на экран.
			myList.showNodes();								// Список до удаления максимального значения.	
			cout << endl << "Максимальный элемент списка: "
				<< myList.findMax() << endl;				// Найденной максимальное значение.
			myList.delNode(myList.findMax());				// Удаление максимального значения.
			cout << "Элементы списка после удаления:" << endl;	// Вывод элементов списка на экран.
			myList.showNodes();								// Список после удаления максимального значения.	
			cout << endl << endl;
			break;
		case 4: system("cls");
			cout << "Элементы списка:" << endl;				// Вывод элементов списка на экран.
			myList.showNodes();
			cout << endl << endl;
			break;
		case 5: system("cls");
			cout << "До свидания!" << endl;
			myList.~SList();								// Вызов деструктора вручную, для отладки.
			exit(0);
		default:
			exit(1);
		}
	}

	cout << endl << endl;
	system("pause");
}

// Общая функция добавления элемента в список, ее будут вызывать дургие функции.
void pushMain(SList* slist, int data)
{
	slist->addNode(data);
}

// Функция добаления элементов в список вручную.
void pushManual(SList *slist)
{
	int n;
	cout << "Сколько значений будете добавлять?: ";
	cin >> n;

	cout << "Введите добавляемые значения через пробел: ";
	int data;

	for (int i = 0; i < n; i++)	// Основная функция добаления вызывается заданное количество раз
	{
		cin >> data;			// и через нее вручную вводится значение.
		pushMain(slist, data);
	}
}

void pushRand(SList *slist)
{
	srand(time(NULL));			// Инициализация ГСЧ.

	int n;
	cout << "Сколько значений будете добавлять?: ";
	cin >> n;

	for (int i = 0; i < n; i++)	// Основная функция добаления вызывается заданное количество раз
	{
		pushMain(slist, rand() % 21 - 10); // и в нее передается случайное значение (-10; 10).
	}
}