/**
*
* Титков Иван
* 30. *В каждой строке массива А(N,M) найти максимальные элементы из
* элементов, встречающихся в строке только один раз. Переставить строки в
* порядке возрастания найденных максимальных элементов. Указатели на строки.
*
*/

#include <iostream>
#include <iomanip>
#include <ctime>

using namespace std;

int** fillRand(int&, int&);		// Прототип функции генерации и ввода массива.
int findMaxUnique(int*, int);	// Прототип функции обработки одной строки массива.
void workArray(int**, int, int);// Прототип функции обработки всего массива с помощью 'findMaxUnique'.
void delArray(int**, int);		// Прототип функции удаления динамического двумерного массива.

int main()
{
	setlocale(LC_ALL, "ru");

	int choice;			// Переменная для главного меню.
	int n = 0;			// Количество строк массива.
	int m = 0;			// Количество столбцов массива.
	int** arr = NULL;	// Указатель на указатель, для двумерного массива.

	// Главное меню.
	while (true)
	{
		cout << "1) Сгенерировать двумерный массив случайных чисел." << endl
			<< "2) Вывод на экран сгенерированного массива и массива с переставленными строками." << endl
			<< "3) Удаление массива из памяти." << endl
			<< "4) Выход." << endl
			<< "Выберите вариант: ";
		cin >> choice;
		switch (choice)
		{
		case 1:	system("cls");
			arr = fillRand(n, m);
			break;
		case 2:	system("cls");
			workArray(arr, n, m);
			break;
		case 3:	system("cls");
			delArray(arr, n);
			cout << "Массив удален." << endl;
			break;
		case 4: system("cls");
			cout << "До свидания!" << endl;
			exit(0);
			break;
		default:
			exit(1);
		}
	}

	cout << endl;
	system("pause");
}

// Функция генерации и ввода массива на экран.
int** fillRand(int &n, int &m)	// По ссылкам значения сохранятся в main.
{
	srand(time(NULL));			// Инициализация ГСЧ.

	cout << "Введите количество строк: ";
	cin >> n;
	cout << "Введите количество столбцов: ";
	cin >> m;

	// Выделение памяти под двумерный массив.
	int** arr = new int*[n];
	for (int i = 0; i < n; i++)
	{
		arr[i] = new int[m];
	}

	// Заполнение массива случайными значениями от -5 до 5
	// и вывод его на экран.
	for (int i = 0; i < n; i++)
	{
		cout << setw(3) << i << ") ";
		for (int j = 0; j < m; j++)
		{
			arr[i][j] = rand() % 11 - 5;
			cout << setw(2) << arr[i][j] << ' ';
		}
		cout << endl;
	}
	cout << endl;

	// Возврат указателя на массив в 'main'.
	return arr;
}

/* Алгоритм проходит по строке, анализируя каждое число на уникальность и, если оно уникально,
*  то проверятся, является ли оно наибольшим из найденных уникальных ранее. И так для каждой строки.
*  Каждое найденное значение записываются во временный массив под индексом, соответсвующим индексу
*  его строки. На основании этой информации потом сортируются строки основного массива.
*  Для этого используются 2 функции.*/

// Функция обработки всего массива.
void workArray(int** arrMain, int n, int m)
{
	if (!arrMain)	// Проверка сгенерирован ли массив.
	{
		system("cls");
		cout << "Сначала сгенерируйте массив!" << endl << endl;
		return;
	}

	int **arrTemp = new int*[2];// Временный массив для хранения результатов работы функции анализа строки, 
	arrTemp[0] = new int[n];	// будет хранить найденные максимальные уникальные величины каждой строки
	arrTemp[1] = new int[n];	// и первоначальный индекс строки элемента, для наглядности. Не обязательно.

	// Передача указателей на строки в функию анализа строки.
	for (int row = 0; row < n; row++)	// Переход по строкам.
	{
		// Найденное значение записывается во временный массив под индексом своей строки.
		arrTemp[0][row] = findMaxUnique(arrMain[row], m);	// Передача строки в функцию.
		arrTemp[1][row] = row;	// Не обязательно. Сохранение первоначального номер строки элемента, для наглядности.
	}

	// Для наглядности вывод сначала первоначального массива.
	cout << "Результат работы алгоритма:" << endl;
	cout << "Первоначальный массив:" << endl;
	for (int i = 0; i < n; i++)
	{
		cout << setw(3) << i << ") ";
		for (int j = 0; j < m; j++)
		{
			cout << setw(2) << arrMain[i][j] << ' ';
		}
		cout << " // макс. уникальное(" << arrTemp[0][i] << ")" << endl;
	}
	cout << endl;

	// Сортировка пузырьком. Сортируется одновременно основной и временный массив на основании информации из
	// временного массива. Строки основного массива	сортируются путем перестановки указателей на строки.
	for (int i = 0; i < n - 1; i++)
	{
		for (int j = 1; j < n - i; j++)
		{
			if (arrTemp[0][j - 1] > arrTemp[0][j])		// По возрастанию
			{
				swap(arrTemp[0][j - 1], arrTemp[0][j]);	// сортируюся переменные во временном массиве
				swap(arrMain[j - 1], arrMain[j]);		// и указатели на строки в основном массиве.
				swap(arrTemp[1][j - 1], arrTemp[1][j]);	// Для наглядности также сохраняем первоначальной номер строки элемента.
			}
		}
	}

	// Вывод на экран отсортированного массива со вспомогательной информацией: предыдущий номер строки
	// и значение максимального уникального элемента.
	cout << "Обработанный массив:" << endl;
	for (int i = 0; i < n; i++)
	{
		cout << setw(3) << arrTemp[1][i] << ") ";
		for (int j = 0; j < m; j++)
		{
			cout << setw(2) << arrMain[i][j] << ' ';
		}
		cout << " // макс. уникальное(" << arrTemp[0][i] << ")" << endl;
	}
	cout << endl;

	// Очистка памяти от временного массива.
	delArray(arrTemp, 2);
}

// Функция поиска максимального уникального элемента в одной строке.
int findMaxUnique(int* pRow, int m)	// Строка передается по указателю.
{
	bool isUnique;					// Флаг, является ли найденное число единственным в строке.
	int maxInRow = INT_MIN;			// Инициализация переменной для сравнения, перед обработкой каждой строки.
	for (int i = 0; i < m; i++)		// Перебор каждого числа в строке.
	{
		isUnique = true;			// По умолчанию каждое число не повторяется.
		for (int j = 0; j < m; j++)	// Цикл для проверки выбранного числа из строки на повторяемость.
		{
			if (j != i && pRow[i] == pRow[j]) // Число не сравнивается само с собой и анализируется на повторяемость.
			{
				isUnique = false;	// Если число повторяется - меняется флаг и переход к следующему числу.
				break;
			}
		}
		if (isUnique && pRow[i] > maxInRow)	// Если НЕ повторяется, то проверка, 
		{									// больше ли предыдущего, и если больше,
			maxInRow = pRow[i];				// то перезаписывается в переменную 'maxInRow'.
		}
	}
	return maxInRow;				// Возврат ответа из функции.
}

// Функция удаления динамического двумерного массива.
void delArray(int **arr, int n)
{
	for (int i = 0; i < n; i++)
	{
		delete[] arr[i];
	}
	delete[] arr;
}